// Code generated by soracom-cli generate-cmd. DO NOT EDIT.
package cmd

import (
	"encoding/json"
	"fmt"
	"io"
	"net/url"
	"os"

	"strings"

	"github.com/spf13/cobra"
)

// StatsHarvestExportCmdExportMode holds value of 'export_mode' option
var StatsHarvestExportCmdExportMode string

// StatsHarvestExportCmdOperatorId holds value of 'operator_id' option
var StatsHarvestExportCmdOperatorId string

// StatsHarvestExportCmdPeriod holds value of 'period' option
var StatsHarvestExportCmdPeriod string

// StatsHarvestExportCmdFrom holds value of 'from' option
var StatsHarvestExportCmdFrom int64

// StatsHarvestExportCmdTo holds value of 'to' option
var StatsHarvestExportCmdTo int64

// StatsHarvestExportCmdBody holds contents of request body to be sent
var StatsHarvestExportCmdBody string

func InitStatsHarvestExportCmd() {
	StatsHarvestExportCmd.Flags().StringVar(&StatsHarvestExportCmdExportMode, "export-mode", "", TRAPI("Specify how to obtain the URL to download the Harvest Data Write Count Results Data CSV.- 'async': Get the 'exportedFieldId' without waiting for the URL to be issued on the Soracom platform. Specify this 'exportedFieldId' in [Files:getExportedFile API](#!/Files/getExportedFile) to get the URL for downloading. If the file size of the Harvest Data Write Count Results Data CSV is huge, specify 'async'.- 'sync' (default): Wait for the URL for downloading to be issued on the Soracom platform. However, if the file size of the Harvest Data Write Count Results Data CSV is huge, it may time out and the URL cannot be retrieved. If the timeout occurs, specify 'async'."))

	StatsHarvestExportCmd.Flags().StringVar(&StatsHarvestExportCmdOperatorId, "operator-id", "", TRAPI("Operator ID."))

	StatsHarvestExportCmd.Flags().StringVar(&StatsHarvestExportCmdPeriod, "period", "", TRAPI("Unit of aggregation.- 'month': Aggregate by month.  The 'from' and 'to' should be UNIX time (in seconds) from 18 months before the current time to the current time. The actual period of interest is not the time specified by 'from' and 'to'.  | Item | Description |  |-|-|  | Actual start time | 00:00:00 on the first day of the month, including the specified UNIX time (in seconds). |  | Actual end time | 24:00:00 of the last day of the month containing the specified UNIX time (in seconds). |- 'day': Aggregate by day.  The 'from' and 'to' should be UNIX time (in seconds) from 18 months before the current time to the current time. The actual period of interest is not the time specified by 'from' and 'to'.  | Item | Description |  |-|-|  | Actual start time | 00:00:00 of the day including the specified UNIX time (in seconds). |  | Actual end time | 24:00:00 of the day including the specified UNIX time (in seconds). |- 'minutes': Aggregate by approximately every 5 minutes.  The 'from' and 'to' must be between 32 days before the current time and the UNIX time (in seconds) of the current time. The actual period to be aggregated is not the time specified by 'from' and 'to'.  | Item | Description |  |-|-|  | Actual Start Time | Start time of approximately 5 minutes including the specified UNIX time (seconds). |  | Actual End Time | End time of approximately 5 minutes including the specified UNIX time (seconds). |"))

	StatsHarvestExportCmd.Flags().Int64Var(&StatsHarvestExportCmdFrom, "from", 0, TRAPI("Specify the start month/day/minute of the period to be aggregated in UNIX time in seconds."))

	StatsHarvestExportCmd.Flags().Int64Var(&StatsHarvestExportCmdTo, "to", 0, TRAPI("Specify the end month/day/minute of the period to be aggregated in UNIX time in seconds."))

	StatsHarvestExportCmd.Flags().StringVar(&StatsHarvestExportCmdBody, "body", "", TRCLI("cli.common_params.body.short_help"))

	StatsHarvestExportCmd.RunE = StatsHarvestExportCmdRunE

	StatsHarvestCmd.AddCommand(StatsHarvestExportCmd)
}

// StatsHarvestExportCmd defines 'export' subcommand
var StatsHarvestExportCmd = &cobra.Command{
	Use:   "export",
	Short: TRAPI("/stats/harvest/operators/{operator_id}/export:post:summary"),
	Long:  TRAPI(`/stats/harvest/operators/{operator_id}/export:post:description`) + "\n\n" + createLinkToAPIReference("Stats", "exportHarvestStats"),
}

func StatsHarvestExportCmdRunE(cmd *cobra.Command, args []string) error {

	if len(args) > 0 {
		return fmt.Errorf("unexpected arguments passed => %v", args)
	}

	opt := &apiClientOptions{
		BasePath: "/v1",
		Language: getSelectedLanguage(),
		Profile:  getProfileIfExists(),
	}

	ac := newAPIClient(opt)
	if v := os.Getenv("SORACOM_VERBOSE"); v != "" {
		ac.SetVerbose(true)
	}
	err := ac.getAPICredentials()
	if err != nil {
		cmd.SilenceUsage = true
		return err
	}

	param, err := collectStatsHarvestExportCmdParams(ac)
	if err != nil {
		return err
	}

	body, err := ac.callAPI(param)
	if err != nil {
		cmd.SilenceUsage = true
		return err
	}

	if body == "" {
		return nil
	}
	rawOutput = true

	if rawOutput {
		_, err = os.Stdout.Write([]byte(body))
	} else {
		return prettyPrintStringAsJSON(body)
	}
	return err
}

func collectStatsHarvestExportCmdParams(ac *apiClient) (*apiParams, error) {
	var body string
	var parsedBody interface{}
	var err error
	if StatsHarvestExportCmdOperatorId == "" {
		StatsHarvestExportCmdOperatorId = ac.apiCredentials.getOperatorID()
	}

	body, err = buildBodyForStatsHarvestExportCmd()
	if err != nil {
		return nil, err
	}
	contentType := "application/json"

	if contentType == "application/json" {
		err = json.Unmarshal([]byte(body), &parsedBody)
		if err != nil {
			return nil, fmt.Errorf("invalid json format specified for `--body` parameter: %s", err)
		}
	}

	return &apiParams{
		method:      "POST",
		path:        buildPathForStatsHarvestExportCmd("/stats/harvest/operators/{operator_id}/export"),
		query:       buildQueryForStatsHarvestExportCmd(),
		contentType: contentType,
		body:        body,

		noRetryOnError: noRetryOnError,
	}, nil
}

func buildPathForStatsHarvestExportCmd(path string) string {

	escapedOperatorId := url.PathEscape(StatsHarvestExportCmdOperatorId)

	path = strReplace(path, "{"+"operator_id"+"}", escapedOperatorId, -1)

	return path
}

func buildQueryForStatsHarvestExportCmd() url.Values {
	result := url.Values{}

	if StatsHarvestExportCmdExportMode != "" {
		result.Add("export_mode", StatsHarvestExportCmdExportMode)
	}

	return result
}

func buildBodyForStatsHarvestExportCmd() (string, error) {
	var result map[string]interface{}

	if StatsHarvestExportCmdBody != "" {
		var b []byte
		var err error

		if strings.HasPrefix(StatsHarvestExportCmdBody, "@") {
			fname := strings.TrimPrefix(StatsHarvestExportCmdBody, "@")
			// #nosec
			b, err = os.ReadFile(fname)
		} else if StatsHarvestExportCmdBody == "-" {
			b, err = io.ReadAll(os.Stdin)
		} else {
			b = []byte(StatsHarvestExportCmdBody)
		}

		if err != nil {
			return "", err
		}

		err = json.Unmarshal(b, &result)
		if err != nil {
			return "", err
		}
	}

	if result == nil {
		result = make(map[string]interface{})
	}

	if StatsHarvestExportCmdPeriod != "" {
		result["period"] = StatsHarvestExportCmdPeriod
	}

	if StatsHarvestExportCmd.Flags().Lookup("from").Changed {
		result["from"] = StatsHarvestExportCmdFrom
	}

	if StatsHarvestExportCmd.Flags().Lookup("to").Changed {
		result["to"] = StatsHarvestExportCmdTo
	}

	resultBytes, err := json.Marshal(result)
	if err != nil {
		return "", err
	}
	return string(resultBytes), nil
}
