// Code generated by soracom-cli generate-cmd. DO NOT EDIT.
package cmd

import (
	"fmt"
	"net/url"
	"os"

	"github.com/spf13/cobra"
)

// SimsListStatusHistoryCmdLastEvaluatedKey holds value of 'last_evaluated_key' option
var SimsListStatusHistoryCmdLastEvaluatedKey string

// SimsListStatusHistoryCmdSimId holds value of 'sim_id' option
var SimsListStatusHistoryCmdSimId string

// SimsListStatusHistoryCmdSort holds value of 'sort' option
var SimsListStatusHistoryCmdSort string

// SimsListStatusHistoryCmdFrom holds value of 'from' option
var SimsListStatusHistoryCmdFrom int64

// SimsListStatusHistoryCmdLimit holds value of 'limit' option
var SimsListStatusHistoryCmdLimit int64

// SimsListStatusHistoryCmdTo holds value of 'to' option
var SimsListStatusHistoryCmdTo int64

// SimsListStatusHistoryCmdPaginate indicates to do pagination or not
var SimsListStatusHistoryCmdPaginate bool

// SimsListStatusHistoryCmdOutputJSONL indicates to output with jsonl format
var SimsListStatusHistoryCmdOutputJSONL bool

func InitSimsListStatusHistoryCmd() {
	SimsListStatusHistoryCmd.Flags().StringVar(&SimsListStatusHistoryCmdLastEvaluatedKey, "last-evaluated-key", "", TRAPI("A string consisting of the primary IMSI and the timestamp (UNIX time in milliseconds) of the last status operation history entry obtained on the previous page, concatenated with '@'. By specifying this parameter, you can continue to retrieve the list from the next page onward."))

	SimsListStatusHistoryCmd.Flags().StringVar(&SimsListStatusHistoryCmdSimId, "sim-id", "", TRAPI("SIM ID of the target SIM."))

	SimsListStatusHistoryCmd.Flags().StringVar(&SimsListStatusHistoryCmdSort, "sort", "desc", TRAPI("Sort order of status operation history entry. Either descending (latest data entry first) or ascending (oldest data entry first)."))

	SimsListStatusHistoryCmd.Flags().Int64Var(&SimsListStatusHistoryCmdFrom, "from", 0, TRAPI("Start time of the status operation history entry to be searched (UNIX time in milliseconds). If not specified, 'from' is set to the oldest status operation history entry time of the target IoT SIM."))

	SimsListStatusHistoryCmd.Flags().Int64Var(&SimsListStatusHistoryCmdLimit, "limit", 30, TRAPI("Maximum number of items to retrieve in one request. The response may contain fewer items than the specified limit."))

	SimsListStatusHistoryCmd.Flags().Int64Var(&SimsListStatusHistoryCmdTo, "to", 0, TRAPI("End time of the status operation history entry to be searched (UNIX time in milliseconds). If not specified, 'to' is set to the current time."))

	SimsListStatusHistoryCmd.Flags().BoolVar(&SimsListStatusHistoryCmdPaginate, "fetch-all", false, TRCLI("cli.common_params.paginate.short_help"))

	SimsListStatusHistoryCmd.Flags().BoolVar(&SimsListStatusHistoryCmdOutputJSONL, "jsonl", false, TRCLI("cli.common_params.jsonl.short_help"))

	SimsListStatusHistoryCmd.RunE = SimsListStatusHistoryCmdRunE

	SimsCmd.AddCommand(SimsListStatusHistoryCmd)
}

// SimsListStatusHistoryCmd defines 'list-status-history' subcommand
var SimsListStatusHistoryCmd = &cobra.Command{
	Use:   "list-status-history",
	Short: TRAPI("/sims/{sim_id}/statuses/history:get:summary"),
	Long:  TRAPI(`/sims/{sim_id}/statuses/history:get:description`) + "\n\n" + createLinkToAPIReference("Sim", "listSimStatusHistory"),
}

func SimsListStatusHistoryCmdRunE(cmd *cobra.Command, args []string) error {

	if len(args) > 0 {
		return fmt.Errorf("unexpected arguments passed => %v", args)
	}

	opt := &apiClientOptions{
		BasePath: "/v1",
		Language: getSelectedLanguage(),
	}

	ac := newAPIClient(opt)
	if v := os.Getenv("SORACOM_VERBOSE"); v != "" {
		ac.SetVerbose(true)
	}
	err := ac.getAPICredentials()
	if err != nil {
		cmd.SilenceUsage = true
		return err
	}

	param, err := collectSimsListStatusHistoryCmdParams(ac)
	if err != nil {
		return err
	}

	body, err := ac.callAPI(param)
	if err != nil {
		cmd.SilenceUsage = true
		return err
	}

	if body == "" {
		return nil
	}

	if rawOutput {
		_, err = os.Stdout.Write([]byte(body))
	} else {
		if SimsListStatusHistoryCmdOutputJSONL {
			return printStringAsJSONL(body)
		}

		return prettyPrintStringAsJSON(body)
	}
	return err
}

func collectSimsListStatusHistoryCmdParams(ac *apiClient) (*apiParams, error) {
	var parsedBody interface{}
	var err error

	err = checkIfRequiredStringParameterIsSupplied("sim_id", "sim-id", "path", parsedBody, SimsListStatusHistoryCmdSimId)
	if err != nil {
		return nil, err
	}

	return &apiParams{
		method: "GET",
		path:   buildPathForSimsListStatusHistoryCmd("/sims/{sim_id}/statuses/history"),
		query:  buildQueryForSimsListStatusHistoryCmd(),

		doPagination:                      SimsListStatusHistoryCmdPaginate,
		paginationKeyHeaderInResponse:     "x-soracom-next-key",
		paginationRequestParameterInQuery: "last_evaluated_key",

		noRetryOnError: noRetryOnError,
	}, nil
}

func buildPathForSimsListStatusHistoryCmd(path string) string {

	escapedSimId := url.PathEscape(SimsListStatusHistoryCmdSimId)

	path = strReplace(path, "{"+"sim_id"+"}", escapedSimId, -1)

	return path
}

func buildQueryForSimsListStatusHistoryCmd() url.Values {
	result := url.Values{}

	if SimsListStatusHistoryCmdLastEvaluatedKey != "" {
		result.Add("last_evaluated_key", SimsListStatusHistoryCmdLastEvaluatedKey)
	}

	if SimsListStatusHistoryCmdSort != "desc" {
		result.Add("sort", SimsListStatusHistoryCmdSort)
	}

	if SimsListStatusHistoryCmdFrom != 0 {
		result.Add("from", sprintf("%d", SimsListStatusHistoryCmdFrom))
	}

	if SimsListStatusHistoryCmdLimit != 30 {
		result.Add("limit", sprintf("%d", SimsListStatusHistoryCmdLimit))
	}

	if SimsListStatusHistoryCmdTo != 0 {
		result.Add("to", sprintf("%d", SimsListStatusHistoryCmdTo))
	}

	return result
}
