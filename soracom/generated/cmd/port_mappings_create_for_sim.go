// Code generated by soracom-cli generate-cmd. DO NOT EDIT.
package cmd

import (
	"encoding/json"
	"fmt"
	"io"
	"net/url"
	"os"

	"strings"

	"github.com/spf13/cobra"
)

// PortMappingsCreateForSimCmdSimId holds value of 'sim_id' option
var PortMappingsCreateForSimCmdSimId string

// PortMappingsCreateForSimCmdDuration holds value of 'duration' option
var PortMappingsCreateForSimCmdDuration float64

// PortMappingsCreateForSimCmdTlsRequired holds value of 'tlsRequired' option
var PortMappingsCreateForSimCmdTlsRequired bool

// PortMappingsCreateForSimCmdBody holds contents of request body to be sent
var PortMappingsCreateForSimCmdBody string

func InitPortMappingsCreateForSimCmd() {
	PortMappingsCreateForSimCmd.Flags().StringVar(&PortMappingsCreateForSimCmdSimId, "sim-id", "", TRAPI("SIM ID of the target IoT SIM."))

	PortMappingsCreateForSimCmd.Flags().Float64Var(&PortMappingsCreateForSimCmdDuration, "duration", 0, TRAPI("The duration (in seconds) to maintain the On-Demand Remote Access entry (the time to allow remote access). After the specified time has passed, the On-Demand Remote Access entry will be automatically deleted. The maximum duration is 8 hours."))

	PortMappingsCreateForSimCmd.Flags().BoolVar(&PortMappingsCreateForSimCmdTlsRequired, "tls-required", false, TRAPI("Whether to encrypt the connection from the source to Soracom using TLS.- 'true': Encrypt using TLS. Specify this if the device is listening on HTTP.- 'false': Do not use TLS. Specify this when connecting to the device via SSH or if the device is listening on HTTPS. Note that communication from the source to the device is encrypted in SSH and HTTPS."))

	PortMappingsCreateForSimCmd.Flags().StringVar(&PortMappingsCreateForSimCmdBody, "body", "", TRCLI("cli.common_params.body.short_help"))

	PortMappingsCreateForSimCmd.RunE = PortMappingsCreateForSimCmdRunE

	PortMappingsCmd.AddCommand(PortMappingsCreateForSimCmd)
}

// PortMappingsCreateForSimCmd defines 'create-for-sim' subcommand
var PortMappingsCreateForSimCmd = &cobra.Command{
	Use:   "create-for-sim",
	Short: TRAPI("/port_mappings/sims/{sim_id}:post:summary"),
	Long:  TRAPI(`/port_mappings/sims/{sim_id}:post:description`) + "\n\n" + createLinkToAPIReference("PortMapping", "createPortMappingForSim"),
}

func PortMappingsCreateForSimCmdRunE(cmd *cobra.Command, args []string) error {

	if len(args) > 0 {
		return fmt.Errorf("unexpected arguments passed => %v", args)
	}

	opt := &apiClientOptions{
		BasePath: "/v1",
		Language: getSelectedLanguage(),
		Profile:  getProfileIfExists(),
	}

	ac := newAPIClient(opt)
	if v := os.Getenv("SORACOM_VERBOSE"); v != "" {
		ac.SetVerbose(true)
	}
	err := ac.getAPICredentials()
	if err != nil {
		cmd.SilenceUsage = true
		return err
	}

	param, err := collectPortMappingsCreateForSimCmdParams(ac)
	if err != nil {
		return err
	}

	body, err := ac.callAPI(param)
	if err != nil {
		cmd.SilenceUsage = true
		return err
	}

	if body == "" {
		return nil
	}

	if rawOutput {
		_, err = os.Stdout.Write([]byte(body))
	} else {
		return prettyPrintStringAsJSON(body)
	}
	return err
}

func collectPortMappingsCreateForSimCmdParams(ac *apiClient) (*apiParams, error) {
	var body string
	var parsedBody interface{}
	var err error
	body, err = buildBodyForPortMappingsCreateForSimCmd()
	if err != nil {
		return nil, err
	}
	contentType := "application/json"

	if contentType == "application/json" {
		err = json.Unmarshal([]byte(body), &parsedBody)
		if err != nil {
			return nil, fmt.Errorf("invalid json format specified for `--body` parameter: %s", err)
		}
	}

	err = checkIfRequiredStringParameterIsSupplied("sim_id", "sim-id", "path", parsedBody, PortMappingsCreateForSimCmdSimId)
	if err != nil {
		return nil, err
	}

	return &apiParams{
		method:      "POST",
		path:        buildPathForPortMappingsCreateForSimCmd("/port_mappings/sims/{sim_id}"),
		query:       buildQueryForPortMappingsCreateForSimCmd(),
		contentType: contentType,
		body:        body,

		noRetryOnError: noRetryOnError,
	}, nil
}

func buildPathForPortMappingsCreateForSimCmd(path string) string {

	escapedSimId := url.PathEscape(PortMappingsCreateForSimCmdSimId)

	path = strReplace(path, "{"+"sim_id"+"}", escapedSimId, -1)

	return path
}

func buildQueryForPortMappingsCreateForSimCmd() url.Values {
	result := url.Values{}

	return result
}

func buildBodyForPortMappingsCreateForSimCmd() (string, error) {
	var result map[string]interface{}

	if PortMappingsCreateForSimCmdBody != "" {
		var b []byte
		var err error

		if strings.HasPrefix(PortMappingsCreateForSimCmdBody, "@") {
			fname := strings.TrimPrefix(PortMappingsCreateForSimCmdBody, "@")
			// #nosec
			b, err = os.ReadFile(fname)
		} else if PortMappingsCreateForSimCmdBody == "-" {
			b, err = io.ReadAll(os.Stdin)
		} else {
			b = []byte(PortMappingsCreateForSimCmdBody)
		}

		if err != nil {
			return "", err
		}

		err = json.Unmarshal(b, &result)
		if err != nil {
			return "", err
		}
	}

	if result == nil {
		result = make(map[string]interface{})
	}

	if PortMappingsCreateForSimCmd.Flags().Lookup("duration").Changed {
		result["duration"] = PortMappingsCreateForSimCmdDuration
	}

	if PortMappingsCreateForSimCmd.Flags().Lookup("tls-required").Changed {
		result["tlsRequired"] = PortMappingsCreateForSimCmdTlsRequired
	}

	resultBytes, err := json.Marshal(result)
	if err != nil {
		return "", err
	}
	return string(resultBytes), nil
}
